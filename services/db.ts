
import { Prompt, PromptVersion, Execution, Evaluation } from '../types';
import { BACKEND_BASE_URL } from '../constants';

/**
 * Database service that communicates with the FastAPI backend
 * running on http://16.171.242.83:8000
 */
class DatabaseService {
  private baseURL = BACKEND_BASE_URL;

  async getPrompts(): Promise<Prompt[]> {
    const res = await fetch(`${this.baseURL}/prompts`);
    if (!res.ok) throw new Error(`Failed to fetch prompts: ${res.statusText}`);
    const data = await res.json();
    
    return data.prompts.map((p: any) => ({
      id: p.id,
      name: p.name,
      description: '',
      createdAt: new Date(p.created_at).getTime()
    }));
  }

  async savePrompt(prompt: Prompt): Promise<Prompt> {
    const res = await fetch(`${this.baseURL}/prompts`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: prompt.name })
    });
    if (!res.ok) throw new Error(`Failed to save prompt: ${res.statusText}`);
    const data = await res.json();
    return {
      id: data.id,
      name: data.name,
      description: '',
      createdAt: new Date(data.created_at).getTime()
    };
  }

  async getVersions(promptId: string): Promise<PromptVersion[]> {
    const res = await fetch(`${this.baseURL}/prompts/${promptId}/versions`);
    if (!res.ok) throw new Error(`Failed to fetch versions: ${res.statusText}`);
    const data = await res.json();
    
    return data.versions.map((v: any) => ({
      id: v.id,
      promptId: v.prompt_id,
      versionNumber: v.version_number,
      content: v.content,
      createdAt: new Date(v.created_at).getTime()
    }));
  }

  async saveVersion(version: PromptVersion): Promise<PromptVersion> {
    const res = await fetch(`${this.baseURL}/prompts/${version.promptId}/version`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content: version.content })
    });
    if (!res.ok) throw new Error(`Failed to save version: ${res.statusText}`);
    const data = await res.json();
    return {
      id: data.id,
      promptId: data.prompt_id,
      versionNumber: data.version_number,
      content: data.content,
      createdAt: new Date(data.created_at).getTime()
    };
  }

  async executeVersion(versionId: string): Promise<{ execution: Execution; evaluation: Evaluation }> {
    const res = await fetch(`${this.baseURL}/execute/${versionId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    });
    if (!res.ok) {
      const error = await res.json();
      throw new Error(`Execution failed: ${error.detail || res.statusText}`);
    }
    const data = await res.json();
    
    const execution: Execution = {
      id: data.execution.id,
      promptVersionId: data.execution.prompt_version_id,
      promptName: '', // Backend doesn't return this, will be set by component
      versionNumber: 0, // Backend doesn't return this
      responseText: data.execution.response_text,
      responseTime: data.execution.response_time,
      createdAt: new Date(data.execution.created_at).getTime(),
      evaluation: undefined
    };

    const evaluation: Evaluation = {
      id: '', // Generated by frontend
      executionId: data.execution.id,
      accuracy: data.evaluation.accuracy_score,
      clarity: data.evaluation.clarity_score,
      hallucinationRisk: data.evaluation.hallucination_score,
      overallScore: data.evaluation.overall_score,
      createdAt: new Date(data.execution.created_at).getTime()
    };

    execution.evaluation = evaluation;
    return { execution, evaluation };
  }

  async getExecutions(): Promise<Execution[]> {
    const res = await fetch(`${this.baseURL}/executions`);
    if (!res.ok) throw new Error(`Failed to fetch executions: ${res.statusText}`);
    const data = await res.json();
    
    return data.executions.map((ex: any) => ({
      id: ex.id,
      promptVersionId: ex.prompt_version_id,
      promptName: '',
      versionNumber: 0,
      responseText: ex.response_text,
      responseTime: ex.response_time,
      createdAt: new Date(ex.created_at).getTime(),
      evaluation: undefined
    }));
  }

  async getMetrics() {
    const res = await fetch(`${this.baseURL}/evaluations`);
    if (!res.ok) return null;
    const data = await res.json();
    const evals = data.evaluations;
    
    if (evals.length === 0) return null;

    const avg = (arr: number[]) => arr.reduce((a, b) => a + b, 0) / arr.length;

    return {
      avgAccuracy: avg(evals.map((e: any) => e.accuracy_score)),
      avgClarity: avg(evals.map((e: any) => e.clarity_score)),
      avgHallucination: avg(evals.map((e: any) => e.hallucination_score)),
      avgOverall: avg(evals.map((e: any) => e.overall_score)),
      totalExecutions: evals.length
    };
  }
}

export const db = new DatabaseService();
